name: ğŸš€ Deploy doc2text

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy"
        required: true

jobs:
  deploy:
    name: ğŸ”„ Deploy via kubectl
    runs-on: self-hosted

    env:
      KUBECONFIG: /etc/rancher/k3s/k3s.yaml
      DOC2TEXT_HTTP_DOMAIN: doc2text.pufferfish.ru
      DOC2TEXT_GRPC_DOMAIN: grpc.doc2text.pufferfish.ru
      DOC2TEXT_HTTP_CERT: doc2text-http-tls
      DOC2TEXT_GRPC_CERT: doc2text-grpc-tls

    steps:
      - name: ğŸ§¾ Checkout repo
        uses: actions/checkout@v4

      - name: ğŸ”§ Ensure namespace
        run: |
          kubectl get ns app >/dev/null 2>&1 || kubectl create ns app

      - name: ğŸ” Apply/update env secret
        env:
          G_RPC_ADDR: ${{ vars.G_RPC_SERVER_DOC2TEXT_ADDR }}
          HTTP_ADDR: ${{ vars.HTTP_SERVER_DOC2TEXT_ADDR }}

          YC_API_KEY: ${{ secrets.YC_API_KEY }}
          YC_IAM_TOKEN: ${{ secrets.YC_IAM_TOKEN }}
          YC_FOLDER_ID: ${{ vars.YC_FOLDER_ID }}
          YC_ENDPOINT: ${{ vars.YC_ENDPOINT }}
          YC_DEFAULT_MODEL: ${{ vars.YC_DEFAULT_MODEL }}
          YC_MIN_CONFIDENCE: ${{ vars.YC_MIN_CONFIDENCE }}
          YC_HTTP_TIMEOUT: ${{ vars.YC_HTTP_TIMEOUT }}
          YC_LANGUAGES: ${{ vars.YC_LANGUAGES }}

          S3_ENDPOINT: ${{ vars.S3_ENDPOINT }}
          S3_ACCESS_KEY: ${{ secrets.S3_ACCESS_KEY }}
          S3_SECRET_KEY: ${{ secrets.S3_SECRET_KEY }}
          S3_BUCKET: ${{ vars.S3_BUCKET }}
          S3_USE_SSL: ${{ vars.S3_USE_SSL }}

          OIDC_ISSUER: ${{ vars.OIDC_DOC2TEXT_ISSUER }}
          OIDC_JWKS_URL: ${{ vars.OIDC_DOC2TEXT_JWKS_URL }}
          OIDC_AUDIENCE: ${{ vars.OIDC_DOC2TEXT_AUDIENCE }}
          OIDC_EXPECTED_AZP: ${{ vars.OIDC_DOC2TEXT_EXPECTED_AZP }}
        run: |
          kubectl -n app create secret generic doc2text-env \
            --from-literal=G_RPC_SERVER_DOC2TEXT_ADDR="${G_RPC_ADDR:-:50052}" \
            --from-literal=HTTP_SERVER_DOC2TEXT_ADDR="${HTTP_ADDR:-:8086}" \
            --from-literal=YC_API_KEY="${YC_API_KEY}" \
            --from-literal=YC_IAM_TOKEN="${YC_IAM_TOKEN}" \
            --from-literal=YC_FOLDER_ID="${YC_FOLDER_ID}" \
            --from-literal=YC_ENDPOINT="${YC_ENDPOINT:-https://vision.api.cloud.yandex.net/vision/v1/batchAnalyze}" \
            --from-literal=YC_DEFAULT_MODEL="${YC_DEFAULT_MODEL:-page}" \
            --from-literal=YC_MIN_CONFIDENCE="${YC_MIN_CONFIDENCE:-0.6}" \
            --from-literal=YC_HTTP_TIMEOUT="${YC_HTTP_TIMEOUT:-15s}" \
            --from-literal=YC_LANGUAGES="${YC_LANGUAGES:-ru,en}" \
            --from-literal=S3_ENDPOINT="${S3_ENDPOINT}" \
            --from-literal=S3_ACCESS_KEY="${S3_ACCESS_KEY}" \
            --from-literal=S3_SECRET_KEY="${S3_SECRET_KEY}" \
            --from-literal=S3_BUCKET="${S3_BUCKET}" \
            --from-literal=S3_USE_SSL="${S3_USE_SSL:-false}" \
            --from-literal=OIDC_DOC2TEXT_ISSUER="${OIDC_ISSUER}" \
            --from-literal=OIDC_DOC2TEXT_JWKS_URL="${OIDC_JWKS_URL}" \
            --from-literal=OIDC_DOC2TEXT_AUDIENCE="${OIDC_AUDIENCE}" \
            --from-literal=OIDC_DOC2TEXT_EXPECTED_AZP="${OIDC_EXPECTED_AZP}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: ğŸ“¤ Apply manifests
        run: |
          kubectl -n app apply -f k8s/doc2text/deploy.yaml
      - name: ğŸ”§ Ensure cert-manager hostAliases for doc2text domains
        shell: bash
        run: |
          DOMAINS=("${DOC2TEXT_HTTP_DOMAIN}" "${DOC2TEXT_GRPC_DOMAIN}")
          NODE_IP=$(kubectl get node -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          echo "Using NODE_IP=${NODE_IP} for domains: ${DOMAINS[*]}"
          kubectl -n cert-manager patch deploy cert-manager --type='json' -p="[
            {
              \"op\": \"replace\",
              \"path\": \"/spec/template/spec/hostAliases\",
              \"value\": [
                {
                  \"ip\": \"${NODE_IP}\",
                  \"hostnames\": [\"${DOC2TEXT_HTTP_DOMAIN}\", \"${DOC2TEXT_GRPC_DOMAIN}\"]
                }
              ]
            }
          ]"
          kubectl -n cert-manager rollout restart deploy/cert-manager
          kubectl -n cert-manager rollout status deploy/cert-manager --timeout=120s
      - name: ğŸ” Wait for TLS certificates (doc2text)
        shell: bash
        run: |
          set -euo pipefail
          wait_for_cert() {
            local CERT_NAME="$1"
            local NAMESPACE="app"
            echo "â³ Waiting for certificate/${CERT_NAME} in ${NAMESPACE}..."
            for i in $(seq 1 60); do
              if kubectl -n "${NAMESPACE}" get certificate "${CERT_NAME}" >/dev/null 2>&1; then
                break
              fi
              sleep 5
              if [ "$i" -eq 60 ]; then
                echo "âŒ certificate/${CERT_NAME} not created"
                exit 1
              fi
            done
            kubectl -n "${NAMESPACE}" wait --for=condition=Ready "certificate/${CERT_NAME}" --timeout=10m
            kubectl -n "${NAMESPACE}" get certificate "${CERT_NAME}"
            echo "Secret type:" "$(kubectl -n "${NAMESPACE}" get secret "${CERT_NAME}" -o jsonpath='{.type}')"
          }
          wait_for_cert "${DOC2TEXT_HTTP_CERT}"
          wait_for_cert "${DOC2TEXT_GRPC_CERT}"
      - name: ğŸ” Orders/Challenges (debug)
        shell: bash
        continue-on-error: true
        run: |
          kubectl -n app get orders.acme.cert-manager.io -o wide || true
          kubectl -n app get challenges.acme.cert-manager.io -o wide || true
      - name: âœ… TLS check (best effort)
        shell: bash
        continue-on-error: true
        run: |
          for DOMAIN in "${DOC2TEXT_HTTP_DOMAIN}" "${DOC2TEXT_GRPC_DOMAIN}"; do
            echo "Certificate info for ${DOMAIN}:"
            echo | openssl s_client -connect "${DOMAIN}:443" -servername "${DOMAIN}" 2>/dev/null | openssl x509 -noout -subject -issuer -dates || true
          done
          echo "HTTP probe over HTTPS (${DOC2TEXT_HTTP_DOMAIN}):"
          curl -I --max-time 15 "https://${DOC2TEXT_HTTP_DOMAIN}" || true

      - name: ğŸ–¼ Update image tag
        env:
          IMAGE_TAG: ${{ github.event.inputs.image_tag }}
        run: |
          REPO=ghcr.io/pufferfish-io/doc2text
          IMAGE="${REPO}:${IMAGE_TAG}"
          echo "Deploying image: ${IMAGE}"
          kubectl -n app set image deployment/doc2text doc2text=${IMAGE}
      - name: ğŸ” Deployed image info
        run: |
          kubectl -n app get deployment doc2text -o jsonpath='{.spec.template.spec.containers[0].image}' | sed 's/^/Image in pod template: /'
          kubectl -n app get deploy doc2text -o jsonpath='{.status.conditions[?(@.type=="Progressing")].message}' || true

      - name: ğŸ” Rollout status
        run: |
          set -e
          kubectl -n app rollout status deployment/doc2text --timeout=180s
          kubectl -n app get pods -o wide

      - name: ğŸ“ Recent logs (best effort)
        continue-on-error: true
        run: |
          kubectl -n app logs deploy/doc2text --tail=200 || true
