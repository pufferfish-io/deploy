name: üöÄ Deploy message-responder-ocr

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (defaults to latest)"
        required: false
        default: "latest"

jobs:
  deploy:
    name: üîÑ Deploy via kubectl
    runs-on: self-hosted
    # environment: prod   # <- –µ—Å–ª–∏ —Ç–≤–æ–∏ org/env-—Å–µ–∫—Ä–µ—Ç—ã –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫ Environment, —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π –∏ —É–∫–∞–∂–∏ –∏–º—è

    env:
      KUBECONFIG: /etc/rancher/k3s/k3s.yaml

    steps:
      - name: üßæ Checkout repo
        uses: actions/checkout@v4

      - name: üîß Ensure namespace
        run: |
          kubectl get ns app || kubectl create ns app

      - name: ‚úÖ Validate required inputs
        env:
          BOOTSTRAP: ${{ vars.KAFKA_BOOTSTRAP_SERVERS_VALUE }}
          GROUP_ID: ${{ vars.KAFKA_GROUP_ID_MESSAGE_RESPONDER_OCR }}
          REQ_TOPIC: ${{ vars.KAFKA_TOPIC_NAME_OCR_REQUEST }}
          RESP_TOPIC: ${{ vars.KAFKA_TOPIC_NAME_TG_RESPONSE_PREPARER }}
          SASL_USER: ${{ secrets.KAFKA_SASL_USERNAME }}
          SASL_PASS: ${{ secrets.KAFKA_SASL_PASSWORD }}
          CLIENT_ID: ${{ vars.KAFKA_CLIENT_ID_MESSAGE_RESPONDER_OCR }}
          DOC3TEXT_TOKEN_URL: ${{ vars.DOC3TEXT_ACCESS_TOKEN_URL }}
          DOC3TEXT_CLIENT_ID: ${{ vars.DOC3TEXT_CLIENT_ID_MESSAGE_RESPONDER_OCR }}
          DOC3TEXT_CLIENT_SECRET: ${{ secrets.DOC3TEXT_CLIENT_SECRET_MESSAGE_RESPONDER_OCR }}
          DOC3TEXT_G_RPC_URL: ${{ vars.DOC3TEXT_G_RPC_URL }}
          SECURITY_PROTOCOL: ${{ vars.KAFKA_SECURITY_PROTOCOL }}
          SASL_MECHANISM: ${{ vars.KAFKA_SASL_MECHANISM }}
        run: |
          set -euo pipefail
          missing=()
          required=(BOOTSTRAP GROUP_ID REQ_TOPIC RESP_TOPIC DOC3TEXT_TOKEN_URL DOC3TEXT_CLIENT_ID DOC3TEXT_CLIENT_SECRET DOC3TEXT_G_RPC_URL SECURITY_PROTOCOL SASL_MECHANISM)
          for key in "${required[@]}"; do
            [[ -z "${!key:-}" ]] && missing+=("$key")
          done
          if (( ${#missing[@]} > 0 )); then
            echo "‚ùå Missing required inputs:" >&2
            for key in "${missing[@]}"; do echo " - $key" >&2; done
            exit 1
          fi
          echo "‚úÖ Required inputs present"

      - name: üîê Apply/update env Secret
        env:
          BOOTSTRAP: ${{ vars.KAFKA_BOOTSTRAP_SERVERS_VALUE }}
          GROUP_ID: ${{ vars.KAFKA_GROUP_ID_MESSAGE_RESPONDER_OCR }}
          REQ_TOPIC: ${{ vars.KAFKA_TOPIC_NAME_OCR_REQUEST }}
          RESP_TOPIC: ${{ vars.KAFKA_TOPIC_NAME_TG_RESPONSE_PREPARER }}
          SASL_USER: ${{ secrets.KAFKA_SASL_USERNAME }}
          SASL_PASS: ${{ secrets.KAFKA_SASL_PASSWORD }}
          CLIENT_ID: ${{ vars.KAFKA_CLIENT_ID_MESSAGE_RESPONDER_OCR }}
          DOC3TEXT_TOKEN_URL: ${{ vars.DOC3TEXT_ACCESS_TOKEN_URL }}
          DOC3TEXT_CLIENT_ID: ${{ vars.DOC3TEXT_CLIENT_ID_MESSAGE_RESPONDER_OCR }}
          DOC3TEXT_CLIENT_SECRET: ${{ secrets.DOC3TEXT_CLIENT_SECRET_MESSAGE_RESPONDER_OCR }}
          DOC3TEXT_G_RPC_URL: ${{ vars.DOC3TEXT_G_RPC_URL }}
          SECURITY_PROTOCOL: ${{ vars.KAFKA_SECURITY_PROTOCOL }}
          SASL_MECHANISM: ${{ vars.KAFKA_SASL_MECHANISM }}
        run: |
          kubectl -n app create secret generic message-responder-ocr-env \
            --from-literal=KAFKA_BOOTSTRAP_SERVERS_VALUE="${BOOTSTRAP}" \
            --from-literal=KAFKA_GROUP_ID_MESSAGE_RESPONDER_OCR="${GROUP_ID}" \
            --from-literal=KAFKA_TOPIC_NAME_OCR_REQUEST="${REQ_TOPIC}" \
            --from-literal=KAFKA_TOPIC_NAME_TG_RESPONSE_PREPARER="${RESP_TOPIC}" \
            --from-literal=KAFKA_SASL_USERNAME="${SASL_USER}" \
            --from-literal=KAFKA_SASL_PASSWORD="${SASL_PASS}" \
            --from-literal=KAFKA_CLIENT_ID_MESSAGE_RESPONDER_OCR="${CLIENT_ID}" \
            --from-literal=KAFKA_SECURITY_PROTOCOL="${SECURITY_PROTOCOL}" \
            --from-literal=KAFKA_SASL_MECHANISM="${SASL_MECHANISM}" \
            --from-literal=DOC3TEXT_ACCESS_TOKEN_URL="${DOC3TEXT_TOKEN_URL}" \
            --from-literal=DOC3TEXT_CLIENT_ID_MESSAGE_RESPONDER_OCR="${DOC3TEXT_CLIENT_ID}" \
            --from-literal=DOC3TEXT_CLIENT_SECRET_MESSAGE_RESPONDER_OCR="${DOC3TEXT_CLIENT_SECRET}" \
            --from-literal=DOC3TEXT_G_RPC_URL="${DOC3TEXT_G_RPC_URL}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: üì§ Apply manifests
        run: |
          kubectl -n app apply -f k8s/message-responder-ocr/deploy.yaml

      # --------- –î–û–ë–ê–í–õ–ï–ù–ù–´–ï –î–ò–ê–ì–ù–û–°–¢–ò–ß–ï–°–ö–ò–ï –®–ê–ì–ò (—Ç–æ–ª—å–∫–æ –∏–º–µ–Ω–∞, –±–µ–∑ –∑–Ω–∞—á–µ–Ω–∏–π) ---------

      - name: üîç Resolved keys in job (names only)
        env:
          KEYS: >-
            BOOTSTRAP
            GROUP_ID
            REQ_TOPIC
            RESP_TOPIC
            SASL_USER
            SASL_PASS
            CLIENT_ID
            SECURITY_PROTOCOL
            SASL_MECHANISM
            DOC3TEXT_TOKEN_URL
            DOC3TEXT_CLIENT_ID
            DOC3TEXT_CLIENT_SECRET
            DOC3TEXT_G_RPC_URL
          BOOTSTRAP:               ${{ vars.KAFKA_BOOTSTRAP_SERVERS_VALUE }}
          GROUP_ID:                ${{ vars.KAFKA_GROUP_ID_MESSAGE_RESPONDER_OCR }}
          REQ_TOPIC:               ${{ vars.KAFKA_TOPIC_NAME_OCR_REQUEST }}
          RESP_TOPIC:              ${{ vars.KAFKA_TOPIC_NAME_TG_RESPONSE_PREPARER }}
          SASL_USER:               ${{ secrets.KAFKA_SASL_USERNAME }}
          SASL_PASS:               ${{ secrets.KAFKA_SASL_PASSWORD }}
          CLIENT_ID:               ${{ vars.KAFKA_CLIENT_ID_MESSAGE_RESPONDER_OCR }}
          SECURITY_PROTOCOL:       ${{ vars.KAFKA_SECURITY_PROTOCOL }}
          SASL_MECHANISM:          ${{ vars.KAFKA_SASL_MECHANISM }}
          DOC3TEXT_TOKEN_URL:      ${{ vars.DOC3TEXT_ACCESS_TOKEN_URL }}
          DOC3TEXT_CLIENT_ID:      ${{ vars.DOC3TEXT_CLIENT_ID_MESSAGE_RESPONDER_OCR }}
          DOC3TEXT_CLIENT_SECRET:  ${{ secrets.DOC3TEXT_CLIENT_SECRET_MESSAGE_RESPONDER_OCR }}
          DOC3TEXT_G_RPC_URL:      ${{ vars.DOC3TEXT_G_RPC_URL }}
        run: |
          set -e
          echo "Resolved non-empty keys in job:"
          for k in $KEYS; do [ -n "${!k:-}" ] && echo " - $k"; done

      - name: üîë Keys in k8s secret (names only)
        run: |
          kubectl -n app get secret message-responder-ocr-env -o json | jq -r '.data | keys[]' | sort

      - name: üß© Deployment env wiring (snippet)
        run: |
          kubectl -n app get deploy message-responder-ocr -o yaml | sed -n '/containers:/,/imagePullPolicy:/p'

      - name: üîé Env names inside running pod (names only)
        run: |
          POD=$(kubectl -n app get pods -l app=message-responder-ocr -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}'); \
          [ -z "$POD" ] && POD=$(kubectl -n app get pods -l app=message-responder-ocr -o jsonpath='{.items[0].metadata.name}'); \
          echo "Pod=$POD"; \
          kubectl -n app exec "$POD" -- sh -lc 'env | egrep "^(KAFKA|SASL|SECURITY|DOC3TEXT|OIDC)_" | cut -d= -f1 | sort'

      # -------------------------------------------------------------------------------

      - name: üñº Update image tag
        env:
          IMAGE_TAG: ${{ github.event.inputs.image_tag }}
        run: |
          TAG=${IMAGE_TAG:-latest}
          REPO=ghcr.io/pufferfish-io/message-responder-ocr
          IMAGE="${REPO}:${TAG}"
          echo "Deploying image: ${IMAGE}"
          kubectl -n app set image deployment/message-responder-ocr message-responder-ocr=${IMAGE}

      - name: üîÅ Roll latest image restart
        env:
          IMAGE_TAG: ${{ github.event.inputs.image_tag }}
        run: |
          TAG=${IMAGE_TAG:-latest}
          if [ "$TAG" = "latest" ]; then
            kubectl -n app rollout restart deployment/message-responder-ocr
          fi

      - name: üîé Rollout status
        run: |
          set -e
          kubectl -n app rollout status deployment/message-responder-ocr --timeout=180s
          kubectl -n app get pods -o wide

      - name: üìù Recent logs (best effort)
        continue-on-error: true
        run: |
          kubectl -n app logs deploy/message-responder-ocr --tail=200